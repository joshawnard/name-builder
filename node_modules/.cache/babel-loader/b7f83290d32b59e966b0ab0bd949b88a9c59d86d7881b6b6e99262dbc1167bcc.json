{"ast":null,"code":"var _jsxFileName = \"/Users/jard/Desktop/code/name-generator/src/components/GeneratorOutput.tsx\",\n  _s = $RefreshSig$();\nimport React, { useContext } from 'react';\nimport NameGeneratorContext from \"../NameGeneratorContext\";\n\n// TODO:\n// Add randomizer that constructs multiple roots together\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst parseDataString = (dataString, language) => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    let languageAndWord = [language, splitString[0], splitString[2]];\n    switch (language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n          languageAndWord = [\"old prussian\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"celtic\":\n        if (splitString[0] === \"OIr\") {\n          languageAndWord = [\"old irish\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"slavic\":\n        if (splitString[0] === \"OCS\") {\n          languageAndWord = [\"old church slavonic\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"tocharian\":\n        if (splitString[0] === \"A\") {\n          languageAndWord = [\"tocharian A\", splitString[1], splitString[2]];\n        }\n        break;\n      default:\n        languageAndWord = [language, splitString[0], splitString[2]];\n        break;\n    }\n    return languageAndWord;\n  }\n  return undefined;\n};\nconst GeneratorOutput = () => {\n  _s();\n  const {\n    rootWordsObj,\n    selectedWords\n  } = useContext(NameGeneratorContext);\n  const formatSelectedWords = () => {\n    const selectedEntries = Object.entries(selectedWords);\n    if (selectedEntries.length) {\n      return Object.entries(selectedWords).map(selectedWord => {\n        const type = selectedWord[0];\n        const list = selectedWord[1];\n        if (list.length) {\n          return list.map(word => {\n            const theOne = rootWordsObj[type].find(rootWordObj => {\n              var _rootWordObj$english;\n              return (_rootWordObj$english = rootWordObj.english) === null || _rootWordObj$english === void 0 ? void 0 : _rootWordObj$english.includes(word);\n            });\n            if (theOne) {\n              return {\n                [word]: Object.entries(theOne).map(entry => {\n                  const parsedWordAndLanguage = parseDataString(entry[1], entry[0]);\n                  if (parsedWordAndLanguage) {\n                    return parsedWordAndLanguage;\n                  }\n                })\n              };\n            }\n          });\n        }\n      });\n    }\n    return null;\n  };\n  const renderSelectedWords = () => {\n    return Object.entries(selectedWords).map(selectedWord => {\n      const type = selectedWord[0];\n      const list = selectedWord[1];\n      if (list.length) {\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: list.map(word => {\n            const theOne = rootWordsObj[type].find(rootWordObj => {\n              var _rootWordObj$english2;\n              return (_rootWordObj$english2 = rootWordObj.english) === null || _rootWordObj$english2 === void 0 ? void 0 : _rootWordObj$english2.includes(word);\n            });\n            if (theOne) {\n              return /*#__PURE__*/_jsxDEV(\"div\", {\n                children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n                  children: word\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 132,\n                  columnNumber: 23\n                }, this), Object.entries(theOne).map(entry => {\n                  return /*#__PURE__*/_jsxDEV(\"div\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                      children: /*#__PURE__*/_jsxDEV(\"b\", {\n                        children: entry[0]\n                      }, void 0, false, {\n                        fileName: _jsxFileName,\n                        lineNumber: 138,\n                        columnNumber: 37\n                      }, this)\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 138,\n                      columnNumber: 31\n                    }, this), \":\", ' ', /*#__PURE__*/_jsxDEV(\"span\", {\n                      children: entry[1]\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 140,\n                      columnNumber: 31\n                    }, this)]\n                  }, entry[0], true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 137,\n                    columnNumber: 29\n                  }, this);\n                })]\n              }, word, true, {\n                fileName: _jsxFileName,\n                lineNumber: 131,\n                columnNumber: 21\n              }, this);\n            }\n            return null;\n          })\n        }, type, false, {\n          fileName: _jsxFileName,\n          lineNumber: 122,\n          columnNumber: 11\n        }, this);\n      }\n    });\n  };\n  const renderFormattedWords = () => {\n    const formatted = formatSelectedWords();\n    if (formatted) {\n      formatted.map(formattedWord => {\n        if (formattedWord) {\n          return formattedWord.map(word => {\n            if (word) {\n              return Object.entries(word).map(wordArr => {\n                const englishWord = wordArr[0];\n                const [lang, translation, engMeaning] = wordArr[1];\n                return /*#__PURE__*/_jsxDEV(\"div\", {\n                  children: [/*#__PURE__*/_jsxDEV(\"strong\", {\n                    children: englishWord\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 172,\n                    columnNumber: 21\n                  }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                    children: lang\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 176,\n                    columnNumber: 21\n                  }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                    children: translation\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 180,\n                    columnNumber: 21\n                  }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n                    children: engMeaning\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 184,\n                    columnNumber: 21\n                  }, this)]\n                }, englishWord, true, {\n                  fileName: _jsxFileName,\n                  lineNumber: 171,\n                  columnNumber: 19\n                }, this);\n              });\n            }\n          });\n        }\n        return /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 195,\n          columnNumber: 11\n        }, this);\n      });\n    }\n    return null;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: renderFormattedWords()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 205,\n    columnNumber: 5\n  }, this);\n};\n_s(GeneratorOutput, \"t3BFoneH8GGetyxUCLHNDbgzoB4=\");\n_c = GeneratorOutput;\nexport default GeneratorOutput;\nvar _c;\n$RefreshReg$(_c, \"GeneratorOutput\");","map":{"version":3,"names":["React","useContext","NameGeneratorContext","parseDataString","dataString","language","splitString","split","languageAndWord","undefined","GeneratorOutput","rootWordsObj","selectedWords","formatSelectedWords","selectedEntries","Object","entries","length","map","selectedWord","type","list","word","theOne","find","rootWordObj","english","includes","entry","parsedWordAndLanguage","renderSelectedWords","renderFormattedWords","formatted","formattedWord","wordArr","englishWord","lang","translation","engMeaning"],"sources":["/Users/jard/Desktop/code/name-generator/src/components/GeneratorOutput.tsx"],"sourcesContent":["import React, { useContext } from 'react';\nimport NameGeneratorContext from \"../NameGeneratorContext\";\n\n// TODO:\n// Add randomizer that constructs multiple roots together\n\nconst parseDataString = (\n  dataString: string | undefined,\n  language: string,\n): [\n  string, // language\n  string, // word\n  string, // english meaning\n] | undefined => {\n  if (dataString) {\n   const splitString = dataString.split(\" \");\n   let languageAndWord: [string, string, string] = [\n     language,\n     splitString[0],\n     splitString[2],\n   ];\n\n   switch(language) {\n     case \"baltic\":\n       if (splitString[0] === \"OPrus\") {\n         languageAndWord = [\n           \"old prussian\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n       break;\n\n     case \"celtic\":\n       if (splitString[0] === \"OIr\") {\n         languageAndWord = [\n           \"old irish\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n       break;\n\n     case \"slavic\":\n       if (splitString[0] === \"OCS\") {\n         languageAndWord = [\n           \"old church slavonic\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     case \"tocharian\":\n       if (splitString[0] === \"A\") {\n         languageAndWord = [\n           \"tocharian A\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     default:\n       languageAndWord = [\n         language,\n         splitString[0],\n         splitString[2],\n       ]\n       break;\n   }\n\n    return languageAndWord;\n  }\n\n  return undefined;\n};\n\nconst GeneratorOutput = () => {\n  const { rootWordsObj, selectedWords } = useContext(NameGeneratorContext);\n\n  const formatSelectedWords = () => {\n    const selectedEntries = Object.entries(selectedWords);\n\n    if (selectedEntries.length) {\n      return Object.entries(selectedWords).map((selectedWord) => {\n        const type = selectedWord[0];\n        const list = selectedWord[1];\n\n        if (list.length) {\n          return list.map((word) => {\n            const theOne = rootWordsObj[type].find((rootWordObj) => {\n              return rootWordObj.english?.includes(word);\n            });\n\n            if (theOne) {\n              return {\n                [word]: Object.entries(theOne).map((entry) => {\n                  const parsedWordAndLanguage = parseDataString(entry[1], entry[0]);\n\n                  if (parsedWordAndLanguage) {\n                    return parsedWordAndLanguage;\n                  }\n                }),\n              };\n            }\n          })\n        }\n      });\n    }\n\n    return null;\n  };\n\n  const renderSelectedWords = () => {\n    return Object.entries(selectedWords).map((selectedWord) => {\n      const type = selectedWord[0];\n      const list = selectedWord[1];\n\n      if (list.length) {\n        return (\n          <div key={type}>\n            {\n              list.map((word) => {\n                const theOne = rootWordsObj[type].find((rootWordObj) => {\n                  return rootWordObj.english?.includes(word);\n                });\n\n                if (theOne) {\n                  return (\n                    <div key={word}>\n                      <h3>{word}</h3>\n\n                      {\n                        Object.entries(theOne).map((entry) => {\n                          return (\n                            <div key={entry[0]}>\n                              <span><b>{entry[0]}</b></span>:\n                              {' '}\n                              <span>{entry[1]}</span>\n                            </div>\n                          );\n                        })\n                      }\n                    </div>\n                  );\n                }\n\n                return null;\n              })\n            }\n          </div>\n        );\n      }\n    })\n  };\n\n  const renderFormattedWords = (): JSX.Element | null => {\n    const formatted = formatSelectedWords();\n\n    if (formatted) {\n      formatted.map((formattedWord) => {\n        if (formattedWord) {\n          return formattedWord.map((word) => {\n            if (word) {\n              return Object.entries(word).map((wordArr) => {\n                const englishWord = wordArr[0];\n                const [lang, translation, engMeaning] = wordArr[1];\n\n                return (\n                  <div key={englishWord}>\n                    <strong>\n                      {englishWord}\n                    </strong>\n\n                    <span>\n                      {lang}\n                    </span>\n\n                    <span>\n                      {translation}\n                    </span>\n\n                    <span>\n                      {engMeaning}\n                    </span>\n                  </div>\n                );\n              });\n            }\n          });\n        }\n\n        return (\n          <div>\n          </div>\n        );\n      })\n    }\n\n    return null;\n  };\n\n  return (\n    <div>\n      {/*{renderSelectedWords()}*/}\n\n      {renderFormattedWords()}\n    </div>\n  );\n};\n\nexport default GeneratorOutput;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}