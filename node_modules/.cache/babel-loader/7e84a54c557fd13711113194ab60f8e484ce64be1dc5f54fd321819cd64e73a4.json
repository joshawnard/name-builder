{"ast":null,"code":"const getWordInQuotes = str => {\n  const match = str.match(/[^\"]+(?=(\" \")|\"$)/g);\n  if (match) {\n    return match[0];\n  }\n  return \"\";\n};\nconst parseDataString = (dataString, language) => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n    // If celtic split by OIr or W?\n    // Maybe leave this as a later feature?\n\n    const defaultLanguageAndWord = {\n      language: language,\n      translation: splitString[1],\n      englishMeaning: getWordInQuotes(dataString)\n    };\n    let languageAndWord = {\n      language: language,\n      translation: splitString[0],\n      englishMeaning: splitString[2]\n    };\n    switch (language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n          languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old prussian\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"celtic\":\n        if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n          languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old irish\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"gaulish\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"iranian\":\n        if (splitString[0] === \"Av\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"avestan\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"slavic\":\n        if (splitString[0] === \"OCS\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old church slavonic\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"tocharian\":\n        if (splitString[0] === \"A\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"tocharian A\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      default:\n        languageAndWord = {\n          language: language,\n          translation: splitString[0],\n          englishMeaning: getWordInQuotes(dataString)\n        };\n        break;\n    }\n    return languageAndWord;\n  }\n  return undefined;\n};\nexport default parseDataString;","map":{"version":3,"names":["getWordInQuotes","str","match","parseDataString","dataString","language","splitString","split","defaultLanguageAndWord","translation","englishMeaning","languageAndWord","includes","undefined"],"sources":["/Users/jard/Desktop/code/name-generator/src/utils/parseDataString.ts"],"sourcesContent":["import { ParsedRootInterface } from \"../interfaces/rootWordInterface\";\n\nconst getWordInQuotes = (str: string) => {\n  const match = str.match(/[^\"]+(?=(\" \")|\"$)/g)\n\n  if (match) {\n    return match[0];\n  }\n\n  return \"\";\n};\n\nconst parseDataString = (\n  dataString: string | undefined,\n  language: string,\n): ParsedRootInterface | undefined => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n    // If celtic split by OIr or W?\n    // Maybe leave this as a later feature?\n\n    const defaultLanguageAndWord = {\n      language: language,\n      translation: splitString[1],\n      englishMeaning: getWordInQuotes(dataString),\n    }\n\n    let languageAndWord: ParsedRootInterface = {\n     language: language,\n     translation: splitString[0],\n     englishMeaning: splitString[2],\n    };\n\n    switch(language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n           languageAndWord = {\n             ...defaultLanguageAndWord,\n             language: \"old prussian\",\n             // translation: splitString[1],\n             // englishMeaning: splitString[2],\n           }\n        }\n\n        break;\n\n      case \"celtic\":\n       if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n         languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"old irish\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"gaulish\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n      case \"iranian\":\n       if (splitString[0] === \"Av\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"avestan\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n       break;\n\n      case \"slavic\":\n       if (splitString[0] === \"OCS\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"old church slavonic\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n      case \"tocharian\":\n       if (splitString[0] === \"A\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"tocharian A\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n      default:\n       languageAndWord = {\n         language: language,\n         translation: splitString[0],\n         englishMeaning: getWordInQuotes(dataString),\n       };\n\n       break;\n    }\n\n    return languageAndWord;\n  }\n\n  return undefined;\n};\n\nexport default parseDataString;"],"mappings":"AAEA,MAAMA,eAAe,GAAIC,GAAW,IAAK;EACvC,MAAMC,KAAK,GAAGD,GAAG,CAACC,KAAK,CAAC,oBAAoB,CAAC;EAE7C,IAAIA,KAAK,EAAE;IACT,OAAOA,KAAK,CAAC,CAAC,CAAC;EACjB;EAEA,OAAO,EAAE;AACX,CAAC;AAED,MAAMC,eAAe,GAAG,CACtBC,UAA8B,EAC9BC,QAAgB,KACoB;EACpC,IAAID,UAAU,EAAE;IACd,MAAME,WAAW,GAAGF,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC;IACzC;IACA;IACA;;IAEA,MAAMC,sBAAsB,GAAG;MAC7BH,QAAQ,EAAEA,QAAQ;MAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;MAC3BI,cAAc,EAAEV,eAAe,CAACI,UAAU;IAC5C,CAAC;IAED,IAAIO,eAAoC,GAAG;MAC1CN,QAAQ,EAAEA,QAAQ;MAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;MAC3BI,cAAc,EAAEJ,WAAW,CAAC,CAAC;IAC9B,CAAC;IAED,QAAOD,QAAQ;MACb,KAAK,QAAQ;QACX,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAC7BK,eAAe,GAAG;YAChB,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACJ;;QAEA;MAEF,KAAK,QAAQ;QACZ,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,CAACO,QAAQ,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACjDK,eAAe,GAAG;YAChB,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAACO,QAAQ,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACzDK,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAED,KAAK,SAAS;QACb,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;UAC3BK,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QACA;MAED,KAAK,QAAQ;QACZ,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;UAC5BK,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAED,KAAK,WAAW;QACf,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC1BK,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGH,sBAAsB;YACzBH,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAED;QACCM,eAAe,GAAG;UAChBN,QAAQ,EAAEA,QAAQ;UAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;UAC3BI,cAAc,EAAEV,eAAe,CAACI,UAAU;QAC5C,CAAC;QAED;IAAM;IAGT,OAAOO,eAAe;EACxB;EAEA,OAAOE,SAAS;AAClB,CAAC;AAED,eAAeV,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}