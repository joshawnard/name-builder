{"ast":null,"code":"const parseDataString = (dataString, language) => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n    // If celtic split by OIr or W?\n    // Maybe leave this as a later feature?\n\n    let languageAndWord = {\n      language: language,\n      translation: splitString[0],\n      englishMeaning: splitString[2]\n    };\n    switch (language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n          languageAndWord = {\n            language: \"old prussian\",\n            translation: splitString[1],\n            englishMeaning: splitString[2]\n          };\n        }\n        break;\n      case \"celtic\":\n        if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n          languageAndWord = [\"old irish\", splitString[1], splitString[2]];\n        }\n        if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n          languageAndWord = [\"gaulish\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"iranian\":\n        if (splitString[0] === \"Av\") {\n          languageAndWord = [\"avestan\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"slavic\":\n        if (splitString[0] === \"OCS\") {\n          languageAndWord = [\"old church slavonic\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"tocharian\":\n        if (splitString[0] === \"A\") {\n          languageAndWord = [\"tocharian A\", splitString[1], splitString[2]];\n        }\n        break;\n      default:\n        languageAndWord = [language, splitString[0], splitString[2]];\n        break;\n    }\n    return languageAndWord;\n  }\n  return undefined;\n};\nexport default parseDataString;","map":{"version":3,"names":["parseDataString","dataString","language","splitString","split","languageAndWord","translation","englishMeaning","includes","undefined"],"sources":["/Users/jard/Desktop/code/name-generator/src/utils/parseDataString.ts"],"sourcesContent":["interface ParsedRootInterface {\n  language: string; // language\n  translation: string; // word\n  englishMeaning: string; // english meaning\n}\n\nconst parseDataString = (\n  dataString: string | undefined,\n  language: string,\n): ParsedRootInterface | undefined => {\n  if (dataString) {\n   const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n   // If celtic split by OIr or W?\n   // Maybe leave this as a later feature?\n\n   let languageAndWord: ParsedRootInterface = {\n     language: language,\n     translation: splitString[0],\n     englishMeaning: splitString[2],\n   };\n\n   switch(language) {\n     case \"baltic\":\n       if (splitString[0] === \"OPrus\") {\n         languageAndWord = {\n           language: \"old prussian\",\n           translation: splitString[1],\n           englishMeaning: splitString[2],\n         }\n       }\n       break;\n\n     case \"celtic\":\n       if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n         languageAndWord = [\n           \"old irish\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n\n       if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n         languageAndWord = [\n           \"gaulish\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n\n       break;\n\n     case \"iranian\":\n       if (splitString[0] === \"Av\") {\n         languageAndWord = [\n           \"avestan\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     case \"slavic\":\n       if (splitString[0] === \"OCS\") {\n         languageAndWord = [\n           \"old church slavonic\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     case \"tocharian\":\n       if (splitString[0] === \"A\") {\n         languageAndWord = [\n           \"tocharian A\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     default:\n       languageAndWord = [\n         language,\n         splitString[0],\n         splitString[2],\n       ]\n       break;\n   }\n\n    return languageAndWord;\n  }\n\n  return undefined;\n};\n\nexport default parseDataString;"],"mappings":"AAMA,MAAMA,eAAe,GAAG,CACtBC,UAA8B,EAC9BC,QAAgB,KACoB;EACpC,IAAID,UAAU,EAAE;IACf,MAAME,WAAW,GAAGF,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC;IACxC;IACD;IACA;;IAEA,IAAIC,eAAoC,GAAG;MACzCH,QAAQ,EAAEA,QAAQ;MAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;MAC3BI,cAAc,EAAEJ,WAAW,CAAC,CAAC;IAC/B,CAAC;IAED,QAAOD,QAAQ;MACb,KAAK,QAAQ;QACX,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAC9BE,eAAe,GAAG;YAChBH,QAAQ,EAAE,cAAc;YACxBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;YAC3BI,cAAc,EAAEJ,WAAW,CAAC,CAAC;UAC/B,CAAC;QACH;QACA;MAEF,KAAK,QAAQ;QACX,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,CAACK,QAAQ,CAACL,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACjDE,eAAe,GAAG,CAChB,WAAW,EACXF,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACH;QAEA,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAACK,QAAQ,CAACL,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACzDE,eAAe,GAAG,CAChB,SAAS,EACTF,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACH;QAEA;MAEF,KAAK,SAAS;QACZ,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;UAC3BE,eAAe,GAAG,CAChB,SAAS,EACTF,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACH;QACA;MAEF,KAAK,QAAQ;QACX,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;UAC5BE,eAAe,GAAG,CAChB,qBAAqB,EACrBF,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACH;QACA;MAEF,KAAK,WAAW;QACd,IAAIA,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC1BE,eAAe,GAAG,CAChB,aAAa,EACbF,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACH;QACA;MAEF;QACEE,eAAe,GAAG,CAChBH,QAAQ,EACRC,WAAW,CAAC,CAAC,CAAC,EACdA,WAAW,CAAC,CAAC,CAAC,CACf;QACD;IAAM;IAGT,OAAOE,eAAe;EACxB;EAEA,OAAOI,SAAS;AAClB,CAAC;AAED,eAAeT,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}