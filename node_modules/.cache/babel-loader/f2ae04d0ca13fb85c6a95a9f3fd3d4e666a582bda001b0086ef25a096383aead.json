{"ast":null,"code":"var _jsxFileName = \"/Users/jard/Desktop/code/name-generator/src/components/GeneratorOutput.tsx\",\n  _s = $RefreshSig$();\nimport React, { useContext, useEffect, useState } from 'react';\nimport NameGeneratorContext from \"../NameGeneratorContext\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// TODO:\n// Add randomizer that constructs multiple roots together\n\nconst parseDataString = (dataString, language) => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    let languageAndWord = [language, splitString[0], splitString[2]];\n    switch (language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n          languageAndWord = [\"old prussian\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"celtic\":\n        if (splitString[0] === \"OIr\") {\n          languageAndWord = [\"old irish\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"slavic\":\n        if (splitString[0] === \"OCS\") {\n          languageAndWord = [\"old church slavonic\", splitString[1], splitString[2]];\n        }\n        break;\n      case \"tocharian\":\n        if (splitString[0] === \"A\") {\n          languageAndWord = [\"tocharian A\", splitString[1], splitString[2]];\n        }\n        break;\n      default:\n        languageAndWord = [language, splitString[0], splitString[2]];\n        break;\n    }\n    return languageAndWord;\n  }\n  return undefined;\n};\nconst formatSelectedWords = (selectedWords, rootWordsObj) => {\n  const selectedEntries = Object.entries(selectedWords);\n  if (selectedEntries.length) {\n    return Object.entries(selectedWords).map(selectedWord => {\n      const type = selectedWord[0];\n      const list = selectedWord[1];\n      if (list.length) {\n        return list.map(word => {\n          const theOne = rootWordsObj[type].find(rootWordObj => {\n            var _rootWordObj$english;\n            return (_rootWordObj$english = rootWordObj.english) === null || _rootWordObj$english === void 0 ? void 0 : _rootWordObj$english.includes(word);\n          });\n          if (theOne) {\n            return {\n              [word]: Object.entries(theOne).map(entry => {\n                const parsedWordAndLanguage = parseDataString(entry[1], entry[0]);\n                if (parsedWordAndLanguage) {\n                  return parsedWordAndLanguage;\n                }\n              })\n            };\n          }\n        });\n      }\n    });\n  }\n  return null;\n};\nconst GeneratorOutput = () => {\n  _s();\n  const {\n    rootWordsObj,\n    selectedWords\n  } = useContext(NameGeneratorContext);\n  const [formattedWordStructures, setFormattedWordStructures] = useState(formatSelectedWords(selectedWords, rootWordsObj));\n  useEffect(() => {\n    setFormattedWordStructures(formatSelectedWords(selectedWords, rootWordsObj));\n  }, [rootWordsObj, selectedWords]);\n  const renderFormattedWords = () => {\n    if (formattedWordStructures) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        children: formattedWordStructures.map(formattedWord => {\n          if (formattedWord) {\n            return formattedWord.map(word => {\n              if (word) {\n                return Object.entries(word).map(list => {\n                  const englishWord = list[0];\n                  return /*#__PURE__*/_jsxDEV(\"div\", {\n                    children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n                      children: englishWord\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 143,\n                      columnNumber: 27\n                    }, this), list[1].map(wordArr => {\n                      if (wordArr) {\n                        const [lang, translation, engMeaning] = wordArr;\n                        return /*#__PURE__*/_jsxDEV(\"div\", {\n                          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n                            children: [lang, \":\"]\n                          }, void 0, true, {\n                            fileName: _jsxFileName,\n                            lineNumber: 154,\n                            columnNumber: 37\n                          }, this), ' ', /*#__PURE__*/_jsxDEV(\"span\", {\n                            children: translation\n                          }, void 0, false, {\n                            fileName: _jsxFileName,\n                            lineNumber: 158,\n                            columnNumber: 37\n                          }, this), ' ', /*#__PURE__*/_jsxDEV(\"span\", {\n                            children: engMeaning\n                          }, void 0, false, {\n                            fileName: _jsxFileName,\n                            lineNumber: 162,\n                            columnNumber: 37\n                          }, this)]\n                        }, translation, true, {\n                          fileName: _jsxFileName,\n                          lineNumber: 153,\n                          columnNumber: 35\n                        }, this);\n                      }\n                    })]\n                  }, englishWord, true, {\n                    fileName: _jsxFileName,\n                    lineNumber: 142,\n                    columnNumber: 25\n                  }, this);\n                });\n              }\n            });\n          }\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 132,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: renderFormattedWords()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 186,\n    columnNumber: 5\n  }, this);\n};\n_s(GeneratorOutput, \"wudkeXtaAJCsKwyKGzXsAFuPSzw=\");\n_c = GeneratorOutput;\nexport default GeneratorOutput;\n\n// const renderSelectedWords = () => {\n//   return Object.entries(selectedWords).map((selectedWord) => {\n//     const type = selectedWord[0];\n//     const list = selectedWord[1];\n//\n//     if (list.length) {\n//       return (\n//         <div key={type}>\n//           {\n//             list.map((word) => {\n//               const theOne = rootWordsObj[type].find((rootWordObj) => {\n//                 return rootWordObj.english?.includes(word);\n//               });\n//\n//               if (theOne) {\n//                 return (\n//                   <div key={word}>\n//                     <h3>{word}</h3>\n//\n//                     {\n//                       Object.entries(theOne).map((entry) => {\n//                         return (\n//                           <div key={entry[0]}>\n//                             <span><b>{entry[0]}</b></span>:\n//                             {' '}\n//                             <span>{entry[1]}</span>\n//                           </div>\n//                         );\n//                       })\n//                     }\n//                   </div>\n//                 );\n//               }\n//\n//               return null;\n//             })\n//           }\n//         </div>\n//       );\n//     }\n//   })\n// };\nvar _c;\n$RefreshReg$(_c, \"GeneratorOutput\");","map":{"version":3,"names":["React","useContext","useEffect","useState","NameGeneratorContext","parseDataString","dataString","language","splitString","split","languageAndWord","undefined","formatSelectedWords","selectedWords","rootWordsObj","selectedEntries","Object","entries","length","map","selectedWord","type","list","word","theOne","find","rootWordObj","english","includes","entry","parsedWordAndLanguage","GeneratorOutput","formattedWordStructures","setFormattedWordStructures","renderFormattedWords","formattedWord","englishWord","wordArr","lang","translation","engMeaning"],"sources":["/Users/jard/Desktop/code/name-generator/src/components/GeneratorOutput.tsx"],"sourcesContent":["import React, { useContext, useEffect, useState } from 'react';\nimport NameGeneratorContext from \"../NameGeneratorContext\";\nimport { SelectedWordsInterface } from \"../types/selectedWords\";\nimport { RootWordsObjInterface } from \"../interfaces/rootWordInterface\";\n\n// TODO:\n// Add randomizer that constructs multiple roots together\n\nconst parseDataString = (\n  dataString: string | undefined,\n  language: string,\n): [\n  string, // language\n  string, // word\n  string, // english meaning\n] | undefined => {\n  if (dataString) {\n   const splitString = dataString.split(\" \");\n   let languageAndWord: [string, string, string] = [\n     language,\n     splitString[0],\n     splitString[2],\n   ];\n\n   switch(language) {\n     case \"baltic\":\n       if (splitString[0] === \"OPrus\") {\n         languageAndWord = [\n           \"old prussian\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n       break;\n\n     case \"celtic\":\n       if (splitString[0] === \"OIr\") {\n         languageAndWord = [\n           \"old irish\",\n           splitString[1],\n           splitString[2]\n         ];\n       }\n       break;\n\n     case \"slavic\":\n       if (splitString[0] === \"OCS\") {\n         languageAndWord = [\n           \"old church slavonic\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     case \"tocharian\":\n       if (splitString[0] === \"A\") {\n         languageAndWord = [\n           \"tocharian A\",\n           splitString[1],\n           splitString[2],\n         ];\n       }\n       break;\n\n     default:\n       languageAndWord = [\n         language,\n         splitString[0],\n         splitString[2],\n       ]\n       break;\n   }\n\n    return languageAndWord;\n  }\n\n  return undefined;\n};\n\nconst formatSelectedWords = (\n  selectedWords: SelectedWordsInterface,\n  rootWordsObj: RootWordsObjInterface,\n) => {\n  const selectedEntries = Object.entries(selectedWords);\n\n  if (selectedEntries.length) {\n    return Object.entries(selectedWords).map((selectedWord) => {\n      const type = selectedWord[0];\n      const list = selectedWord[1];\n\n      if (list.length) {\n        return list.map((word) => {\n          const theOne = rootWordsObj[type].find((rootWordObj) => {\n            return rootWordObj.english?.includes(word);\n          });\n\n          if (theOne) {\n            return {\n              [word]: Object.entries(theOne).map((entry) => {\n                const parsedWordAndLanguage = parseDataString(entry[1], entry[0]);\n\n                if (parsedWordAndLanguage) {\n                  return parsedWordAndLanguage;\n                }\n              }),\n            };\n          }\n        })\n      }\n    });\n  }\n\n  return null;\n};\n\nconst GeneratorOutput = () => {\n  const { rootWordsObj, selectedWords } = useContext(NameGeneratorContext);\n  const [formattedWordStructures, setFormattedWordStructures] = useState(\n    formatSelectedWords(selectedWords, rootWordsObj),\n  );\n\n  useEffect(() => {\n    setFormattedWordStructures(\n      formatSelectedWords(selectedWords, rootWordsObj),\n    );\n  }, [rootWordsObj, selectedWords])\n\n  const renderFormattedWords = (): JSX.Element | null => {\n    if (formattedWordStructures) {\n      return (\n        <div>\n          {\n            formattedWordStructures.map((formattedWord) => {\n              if (formattedWord) {\n                return formattedWord.map((word) => {\n                  if (word) {\n                    return Object.entries(word).map((list) => {\n                      const englishWord = list[0];\n\n                      return (\n                        <div key={englishWord}>\n                          <h4>\n                            {englishWord}\n                          </h4>\n\n                          {\n                            list[1].map((wordArr) => {\n                              if (wordArr) {\n                                const [lang, translation, engMeaning] = wordArr;\n\n                                return (\n                                  <div key={translation}>\n                                    <span>\n                                      {lang}:\n                                    </span>\n                                    {' '}\n                                    <span>\n                                      {translation}\n                                    </span>\n                                    {' '}\n                                    <span>\n                                      {engMeaning}\n                                    </span>\n                                  </div>\n                                );\n                              }\n                            })\n                          }\n                        </div>\n                      );\n                    });\n                  }\n                });\n              }\n            })\n          }\n        </div>\n      );\n    }\n\n    return null;\n  };\n\n  return (\n    <div>\n      {/*{renderSelectedWords()}*/}\n\n      {renderFormattedWords()}\n    </div>\n  );\n};\n\nexport default GeneratorOutput;\n\n// const renderSelectedWords = () => {\n//   return Object.entries(selectedWords).map((selectedWord) => {\n//     const type = selectedWord[0];\n//     const list = selectedWord[1];\n//\n//     if (list.length) {\n//       return (\n//         <div key={type}>\n//           {\n//             list.map((word) => {\n//               const theOne = rootWordsObj[type].find((rootWordObj) => {\n//                 return rootWordObj.english?.includes(word);\n//               });\n//\n//               if (theOne) {\n//                 return (\n//                   <div key={word}>\n//                     <h3>{word}</h3>\n//\n//                     {\n//                       Object.entries(theOne).map((entry) => {\n//                         return (\n//                           <div key={entry[0]}>\n//                             <span><b>{entry[0]}</b></span>:\n//                             {' '}\n//                             <span>{entry[1]}</span>\n//                           </div>\n//                         );\n//                       })\n//                     }\n//                   </div>\n//                 );\n//               }\n//\n//               return null;\n//             })\n//           }\n//         </div>\n//       );\n//     }\n//   })\n// };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}