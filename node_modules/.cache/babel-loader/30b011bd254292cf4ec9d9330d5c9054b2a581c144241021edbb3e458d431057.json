{"ast":null,"code":"import removeExtraChars from \"./removeExtraChars\";\nconst generateNames = formattedWordStructures => {\n  if (formattedWordStructures && formattedWordStructures[0]) {\n    let generated = [];\n    const structures = formattedWordStructures.flat();\n    const numNames = 1000;\n    Array.from(Array(numNames)).forEach(time => {\n      let numOfRoots = Math.floor(Math.random() * structures.length);\n      if (numOfRoots < 2) {\n        numOfRoots = 2;\n      }\n      if (numOfRoots > 3) {\n        numOfRoots = 3;\n      }\n      let nameKey = \"\";\n      let rootsArr = [];\n      for (let i = 0; i < numOfRoots; i++) {\n        const randomStructureIndex = Math.floor(Math.random() * structures.length);\n        const randomStructure = structures[randomStructureIndex];\n        if (randomStructure) {\n          const translationList = Object.entries(randomStructure).map(entry => {\n            return entry[1].filter(element => {\n              return element !== undefined;\n            });\n          })[0];\n          const randomTranslationIndex = Math.floor(Math.random() * (translationList.length - 1));\n          const translationObj = translationList[randomTranslationIndex];\n          nameKey += translationObj !== null && translationObj !== void 0 && translationObj.translation ? removeExtraChars(translationObj.translation) : \"\";\n          rootsArr.push(translationObj);\n        }\n      }\n      const alreadyExists = !!generated.find(obj => Object.keys(obj)[0] === nameKey);\n      if (!alreadyExists) {\n        generated.push({\n          [nameKey]: rootsArr\n        });\n      }\n    });\n    return generated;\n  }\n  return [];\n};\nexport default generateNames;","map":{"version":3,"names":["removeExtraChars","generateNames","formattedWordStructures","generated","structures","flat","numNames","Array","from","forEach","time","numOfRoots","Math","floor","random","length","nameKey","rootsArr","i","randomStructureIndex","randomStructure","translationList","Object","entries","map","entry","filter","element","undefined","randomTranslationIndex","translationObj","translation","push","alreadyExists","find","obj","keys"],"sources":["/Users/jard/Desktop/code/name-generator/src/utils/generateNames.ts"],"sourcesContent":["import { FormattedWordStructures, GeneratedName, ParsedRootInterface } from \"../interfaces/rootWordInterface\";\nimport removeExtraChars from \"./removeExtraChars\";\n\nconst generateNames = (\n  formattedWordStructures: FormattedWordStructures,\n): GeneratedName[] => {\n  if (formattedWordStructures && formattedWordStructures[0]) {\n    let generated: { [key: string]: ParsedRootInterface[] }[] = [];\n    const structures = formattedWordStructures.flat();\n\n    const numNames = 1000;\n    Array.from(Array(numNames)).forEach((time) => {\n      let numOfRoots = Math.floor(Math.random() * (structures.length));\n      if (numOfRoots < 2) {\n        numOfRoots = 2;\n      }\n      if (numOfRoots > 3) {\n        numOfRoots = 3;\n      }\n\n      let nameKey = \"\";\n      let rootsArr: ParsedRootInterface[] = [];\n\n      for (let i = 0; i < numOfRoots; i++) {\n        const randomStructureIndex = Math.floor(Math.random() * (structures.length));\n        const randomStructure = structures[randomStructureIndex];\n\n        if (randomStructure) {\n          const translationList = Object.entries(randomStructure).map((entry) => {\n            return entry[1].filter((element) => {\n              return element !== undefined;\n            });\n          })[0]\n\n          const randomTranslationIndex = Math.floor(Math.random() * (translationList.length - 1));\n          const translationObj = translationList[randomTranslationIndex];\n\n          nameKey += translationObj?.translation ? removeExtraChars(translationObj.translation) : \"\";\n          rootsArr.push(translationObj as ParsedRootInterface);\n        }\n      }\n\n      const alreadyExists = !!generated.find((obj) => Object.keys(obj)[0] === nameKey);\n      if (!alreadyExists) {\n        generated.push({\n          [nameKey]: rootsArr,\n        });\n      }\n    })\n\n    return generated;\n  }\n\n  return [];\n};\n\nexport default generateNames;"],"mappings":"AACA,OAAOA,gBAAgB,MAAM,oBAAoB;AAEjD,MAAMC,aAAa,GACjBC,uBAAgD,IAC5B;EACpB,IAAIA,uBAAuB,IAAIA,uBAAuB,CAAC,CAAC,CAAC,EAAE;IACzD,IAAIC,SAAqD,GAAG,EAAE;IAC9D,MAAMC,UAAU,GAAGF,uBAAuB,CAACG,IAAI,EAAE;IAEjD,MAAMC,QAAQ,GAAG,IAAI;IACrBC,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,QAAQ,CAAC,CAAC,CAACG,OAAO,CAAEC,IAAI,IAAK;MAC5C,IAAIC,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAIV,UAAU,CAACW,MAAO,CAAC;MAChE,IAAIJ,UAAU,GAAG,CAAC,EAAE;QAClBA,UAAU,GAAG,CAAC;MAChB;MACA,IAAIA,UAAU,GAAG,CAAC,EAAE;QAClBA,UAAU,GAAG,CAAC;MAChB;MAEA,IAAIK,OAAO,GAAG,EAAE;MAChB,IAAIC,QAA+B,GAAG,EAAE;MAExC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,UAAU,EAAEO,CAAC,EAAE,EAAE;QACnC,MAAMC,oBAAoB,GAAGP,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,GAAIV,UAAU,CAACW,MAAO,CAAC;QAC5E,MAAMK,eAAe,GAAGhB,UAAU,CAACe,oBAAoB,CAAC;QAExD,IAAIC,eAAe,EAAE;UACnB,MAAMC,eAAe,GAAGC,MAAM,CAACC,OAAO,CAACH,eAAe,CAAC,CAACI,GAAG,CAAEC,KAAK,IAAK;YACrE,OAAOA,KAAK,CAAC,CAAC,CAAC,CAACC,MAAM,CAAEC,OAAO,IAAK;cAClC,OAAOA,OAAO,KAAKC,SAAS;YAC9B,CAAC,CAAC;UACJ,CAAC,CAAC,CAAC,CAAC,CAAC;UAEL,MAAMC,sBAAsB,GAAGjB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,EAAE,IAAIO,eAAe,CAACN,MAAM,GAAG,CAAC,CAAC,CAAC;UACvF,MAAMe,cAAc,GAAGT,eAAe,CAACQ,sBAAsB,CAAC;UAE9Db,OAAO,IAAIc,cAAc,aAAdA,cAAc,eAAdA,cAAc,CAAEC,WAAW,GAAG/B,gBAAgB,CAAC8B,cAAc,CAACC,WAAW,CAAC,GAAG,EAAE;UAC1Fd,QAAQ,CAACe,IAAI,CAACF,cAAc,CAAwB;QACtD;MACF;MAEA,MAAMG,aAAa,GAAG,CAAC,CAAC9B,SAAS,CAAC+B,IAAI,CAAEC,GAAG,IAAKb,MAAM,CAACc,IAAI,CAACD,GAAG,CAAC,CAAC,CAAC,CAAC,KAAKnB,OAAO,CAAC;MAChF,IAAI,CAACiB,aAAa,EAAE;QAClB9B,SAAS,CAAC6B,IAAI,CAAC;UACb,CAAChB,OAAO,GAAGC;QACb,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;IAEF,OAAOd,SAAS;EAClB;EAEA,OAAO,EAAE;AACX,CAAC;AAED,eAAeF,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}