{"ast":null,"code":"const getWordInQuotes = str => {\n  return str.match(\"(.*?)\") || \"\";\n};\nconst parseDataString = (dataString, language) => {\n  if (dataString) {\n    const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n    // If celtic split by OIr or W?\n    // Maybe leave this as a later feature?\n\n    let languageAndWord = {\n      language: language,\n      translation: splitString[0],\n      englishMeaning: splitString[2]\n    };\n    const defaultLanguageAndWord = {\n      language: \"\",\n      translation: splitString[1],\n      englishMeaning: getWordInQuotes(dataString)\n    };\n    switch (language) {\n      case \"baltic\":\n        if (splitString[0] === \"OPrus\") {\n          languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old prussian\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"celtic\":\n        if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n          languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old irish\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"gaulish\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"iranian\":\n        if (splitString[0] === \"Av\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"avestan\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"slavic\":\n        if (splitString[0] === \"OCS\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"old church slavonic\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      case \"tocharian\":\n        if (splitString[0] === \"A\") {\n          languageAndWord = languageAndWord = {\n            ...defaultLanguageAndWord,\n            language: \"tocharian A\"\n            // translation: splitString[1],\n            // englishMeaning: splitString[2],\n          };\n        }\n\n        break;\n      default:\n        languageAndWord = {\n          language: language,\n          translation: splitString[0],\n          englishMeaning: splitString[2]\n        };\n        break;\n    }\n    return languageAndWord;\n  }\n  return undefined;\n};\nexport default parseDataString;","map":{"version":3,"names":["getWordInQuotes","str","match","parseDataString","dataString","language","splitString","split","languageAndWord","translation","englishMeaning","defaultLanguageAndWord","includes","undefined"],"sources":["/Users/jard/Desktop/code/name-generator/src/utils/parseDataString.ts"],"sourcesContent":["import { ParsedRootInterface } from \"../interfaces/rootWordInterface\";\n\nconst getWordInQuotes = (str: string) => {\n  return str.match(\"(.*?)\") || \"\";\n};\n\nconst parseDataString = (\n  dataString: string | undefined,\n  language: string,\n): ParsedRootInterface | undefined => {\n  if (dataString) {\n   const splitString = dataString.split(\" \");\n    // TODO: split by language strings?\n   // If celtic split by OIr or W?\n   // Maybe leave this as a later feature?\n\n   let languageAndWord: ParsedRootInterface = {\n     language: language,\n     translation: splitString[0],\n     englishMeaning: splitString[2],\n   };\n\n   const defaultLanguageAndWord = {\n     language: \"\",\n     translation: splitString[1],\n     englishMeaning: getWordInQuotes(dataString),\n   }\n\n   switch(language) {\n     case \"baltic\":\n       if (splitString[0] === \"OPrus\") {\n         languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"old prussian\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n     case \"celtic\":\n       if ([\"OIr\", \"Old Irish\"].includes(splitString[0])) {\n         languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"old irish\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       if ([\"Gaul\", \"Gaul.\", \"Gaulish\"].includes(splitString[0])) {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"gaulish\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n     case \"iranian\":\n       if (splitString[0] === \"Av\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"avestan\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n       break;\n\n     case \"slavic\":\n       if (splitString[0] === \"OCS\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"old church slavonic\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n     case \"tocharian\":\n       if (splitString[0] === \"A\") {\n         languageAndWord = languageAndWord = {\n           ...defaultLanguageAndWord,\n           language: \"tocharian A\",\n           // translation: splitString[1],\n           // englishMeaning: splitString[2],\n         }\n       }\n\n       break;\n\n     default:\n       languageAndWord = {\n         language: language,\n         translation: splitString[0],\n         englishMeaning: splitString[2],\n       };\n\n       break;\n   }\n\n    return languageAndWord;\n  }\n\n  return undefined;\n};\n\nexport default parseDataString;"],"mappings":"AAEA,MAAMA,eAAe,GAAIC,GAAW,IAAK;EACvC,OAAOA,GAAG,CAACC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE;AACjC,CAAC;AAED,MAAMC,eAAe,GAAG,CACtBC,UAA8B,EAC9BC,QAAgB,KACoB;EACpC,IAAID,UAAU,EAAE;IACf,MAAME,WAAW,GAAGF,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC;IACxC;IACD;IACA;;IAEA,IAAIC,eAAoC,GAAG;MACzCH,QAAQ,EAAEA,QAAQ;MAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;MAC3BI,cAAc,EAAEJ,WAAW,CAAC,CAAC;IAC/B,CAAC;IAED,MAAMK,sBAAsB,GAAG;MAC7BN,QAAQ,EAAE,EAAE;MACZI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;MAC3BI,cAAc,EAAEV,eAAe,CAACI,UAAU;IAC5C,CAAC;IAED,QAAOC,QAAQ;MACb,KAAK,QAAQ;QACX,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,OAAO,EAAE;UAC9BE,eAAe,GAAG;YAChB,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAEF,KAAK,QAAQ;QACX,IAAI,CAAC,KAAK,EAAE,WAAW,CAAC,CAACO,QAAQ,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACjDE,eAAe,GAAG;YAChB,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAACO,QAAQ,CAACN,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE;UACzDE,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAEF,KAAK,SAAS;QACZ,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;UAC3BE,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QACA;MAEF,KAAK,QAAQ;QACX,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;UAC5BE,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAEF,KAAK,WAAW;QACd,IAAIC,WAAW,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC1BE,eAAe,GAAGA,eAAe,GAAG;YAClC,GAAGG,sBAAsB;YACzBN,QAAQ,EAAE;YACV;YACA;UACF,CAAC;QACH;;QAEA;MAEF;QACEG,eAAe,GAAG;UAChBH,QAAQ,EAAEA,QAAQ;UAClBI,WAAW,EAAEH,WAAW,CAAC,CAAC,CAAC;UAC3BI,cAAc,EAAEJ,WAAW,CAAC,CAAC;QAC/B,CAAC;QAED;IAAM;IAGT,OAAOE,eAAe;EACxB;EAEA,OAAOK,SAAS;AAClB,CAAC;AAED,eAAeV,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}